#include "StencilOne.h"


const DWORD VertexStencil::FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;

CStencilOne::CStencilOne(void)
{
	m_VB = 0;

	m_FloorTex  = 0;
	m_WallTex   = 0;
	m_MirrorTex = 0;

	m_FloorMtrl  = d3d::WHITE_MTRL;
	m_WallMtrl   = d3d::WHITE_MTRL;
	m_MirrorMtrl = d3d::WHITE_MTRL;

	m_Teapot = 0;
	m_TeapotPosition = D3DXVECTOR3(0.0f, 3.0f, -7.5f);
	m_TeapotMtrl = d3d::WHITE_MTRL;

	m_TexCube = 0;
	m_VBCube = 0;
	m_IBCube = 0;
}
//-------------------------------------------------------------------------
CStencilOne::~CStencilOne(void)
{
}
//-------------------------------------------------------------------------
bool CStencilOne::Setup(IDirect3DDevice9* pDevice,int nWidth,int nHeight)
{
	if (pDevice == 0)
	{
		return false;
	}
	m_Device = pDevice;
	m_nWidth = nWidth;
	m_nHeight = nHeight;

	//
	// Make walls have low specular reflectance - 20%.
	//

	m_WallMtrl.Specular = d3d::WHITE * 0.2f;

	//
	// Create the teapot.
	//

	//D3DXCreateTeapot(m_Device, &m_Teapot, 0);

	//
	// Create and specify geometry.  For this sample we draw a floor
	// and a wall with a mirror on it.  We put the floor, wall, and
	// mirror geometry in one vertex buffer.
	//
	//   |----|----|----|
	//   |Wall|Mirr|Wall|
	//   |    | or |    |
	//   /--------------/
	//  /   Floor      /
	// /--------------/
	//
	m_Device->CreateVertexBuffer(
		24 * sizeof(VertexStencil),
		0, // usage
		VertexStencil::FVF,
		D3DPOOL_MANAGED,
		&m_VB,
		0);

	VertexStencil* v = 0;
	m_VB->Lock(0, 0, (void**)&v, 0);

	// floor
	v[0] = VertexStencil(-7.5f, 0.0f, -10.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f);
	v[1] = VertexStencil(-7.5f, 0.0f,   0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f);
	v[2] = VertexStencil( 7.5f, 0.0f,   0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);

	v[3] = VertexStencil(-7.5f, 0.0f, -10.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f);
	v[4] = VertexStencil( 7.5f, 0.0f,   0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);
	v[5] = VertexStencil( 7.5f, 0.0f, -10.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f);

	// wall
	v[6]  = VertexStencil(-7.5f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);
	v[7]  = VertexStencil(-7.5f, 5.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);
	v[8]  = VertexStencil(-2.5f, 5.0f, 0.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);

	v[9]  = VertexStencil(-7.5f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);
	v[10] = VertexStencil(-2.5f, 5.0f, 0.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);
	v[11] = VertexStencil(-2.5f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);

	// Note: We leave gap in middle of walls for mirror

	v[12] = VertexStencil(2.5f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);
	v[13] = VertexStencil(2.5f, 5.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);
	v[14] = VertexStencil(7.5f, 5.0f, 0.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);

	v[15] = VertexStencil(2.5f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);
	v[16] = VertexStencil(7.5f, 5.0f, 0.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);
	v[17] = VertexStencil(7.5f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);

	// mirror
	v[18] = VertexStencil(-2.5f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);
	v[19] = VertexStencil(-2.5f, 5.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);
	v[20] = VertexStencil( 2.5f, 5.0f, 0.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);

	v[21] = VertexStencil(-2.5f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);
	v[22] = VertexStencil( 2.5f, 5.0f, 0.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);
	v[23] = VertexStencil( 2.5f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);

	m_VB->Unlock();

	//
	// Load Textures, set filters.
	//

	D3DXCreateTextureFromFile(m_Device, s_szCheckerPath, &m_FloorTex);
	D3DXCreateTextureFromFile(m_Device, s_szBrick0Path, &m_WallTex);
	D3DXCreateTextureFromFile(m_Device, s_szIcePath, &m_MirrorTex);
	

	__CreateCubeBox();

	m_Device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
	m_Device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
	m_Device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);

	//
	// Lights.
	//

	D3DXVECTOR3 lightDir(0.707f, -0.707f, 0.707f);
	D3DXCOLOR color(1.0f, 1.0f, 1.0f, 1.0f);
	D3DLIGHT9 light = d3d::InitDirectionalLight(&lightDir, &color);

	m_Device->SetLight(0, &light);
	m_Device->LightEnable(0, true);

	m_Device->SetRenderState(D3DRS_NORMALIZENORMALS, true);
	m_Device->SetRenderState(D3DRS_SPECULARENABLE, true);

	//
	// Set Camera.
	//

	D3DXVECTOR3		pos(-10.0f, 3.0f, -15.0f);
	D3DXVECTOR3		target(0.0, 0.0f, 0.0f);
	D3DXVECTOR3     up(0.0f, 1.0f, 0.0f);

	D3DXMATRIX V;
	D3DXMatrixLookAtLH(&V, &pos, &target, &up);

	m_Device->SetTransform(D3DTS_VIEW, &V);

	//
	// Set projection matrix.
	//
	// Í¸ÊÓÍ¶Ó°
	//
	//
	// 
	D3DXMATRIX proj;
	D3DXMatrixPerspectiveFovLH(
		&proj,
		D3DX_PI / 4.0f, // 45 - degree
		(float)m_nWidth / (float)m_nHeight,
		1.0f,
		1000.0f);
	m_Device->SetTransform(D3DTS_PROJECTION, &proj);

	return true;
}
//-------------------------------------------------------------------------
void CStencilOne::__CreateCubeBox()
{
	m_Device->CreateVertexBuffer(
		24 * sizeof(VertexStencil), 
		D3DUSAGE_WRITEONLY, // usage
		VertexStencil::FVF,
		D3DPOOL_MANAGED,
		&m_VBCube,
		0);

	VertexStencil* v;
	m_VBCube->Lock(0, 0, (void**)&v, 0);

	// build box

	// fill in the front face vertex data
	v[0] = VertexStencil(-1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);
	v[1] = VertexStencil(-1.0f,  1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);
	v[2] = VertexStencil( 1.0f,  1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);
	v[3] = VertexStencil( 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);

	// fill in the back face vertex data
	v[4] = VertexStencil(-1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);
	v[5] = VertexStencil( 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f);
	v[6] = VertexStencil( 1.0f,  1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);
	v[7] = VertexStencil(-1.0f,  1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f);

	// fill in the top face vertex data
	v[8]  = VertexStencil(-1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f);
	v[9]  = VertexStencil(-1.0f, 1.0f,  1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f);
	v[10] = VertexStencil( 1.0f, 1.0f,  1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f);
	v[11] = VertexStencil( 1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);

	// fill in the bottom face vertex data
	v[12] = VertexStencil(-1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f);
	v[13] = VertexStencil( 1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f);
	v[14] = VertexStencil( 1.0f, -1.0f,  1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f);
	v[15] = VertexStencil(-1.0f, -1.0f,  1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f);

	// fill in the left face vertex data
	v[16] = VertexStencil(-1.0f, -1.0f,  1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f);
	v[17] = VertexStencil(-1.0f,  1.0f,  1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
	v[18] = VertexStencil(-1.0f,  1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f);
	v[19] = VertexStencil(-1.0f, -1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f);

	// fill in the right face vertex data
	v[20] = VertexStencil( 1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);
	v[21] = VertexStencil( 1.0f,  1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
	v[22] = VertexStencil( 1.0f,  1.0f,  1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);
	v[23] = VertexStencil( 1.0f, -1.0f,  1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);

	m_VBCube->Unlock();

	m_Device->CreateIndexBuffer(
		36 * sizeof(WORD),
		D3DUSAGE_WRITEONLY, // usage
		D3DFMT_INDEX16,
		D3DPOOL_MANAGED,
		&m_IBCube,
		0);

	WORD* i = 0;
	m_IBCube->Lock(0, 0, (void**)&i, 0);

	// fill in the front face index data
	i[0] = 0; i[1] = 1; i[2] = 2;
	i[3] = 0; i[4] = 2; i[5] = 3;

	// fill in the back face index data
	i[6] = 4; i[7]  = 5; i[8]  = 6;
	i[9] = 4; i[10] = 6; i[11] = 7;

	// fill in the top face index data
	i[12] = 8; i[13] =  9; i[14] = 10;
	i[15] = 8; i[16] = 10; i[17] = 11;

	// fill in the bottom face index data
	i[18] = 12; i[19] = 13; i[20] = 14;
	i[21] = 12; i[22] = 14; i[23] = 15;

	// fill in the left face index data
	i[24] = 16; i[25] = 17; i[26] = 18;
	i[27] = 16; i[28] = 18; i[29] = 19;

	// fill in the right face index data
	i[30] = 20; i[31] = 21; i[32] = 22;
	i[33] = 20; i[34] = 22; i[35] = 23;

	m_IBCube->Unlock();

	D3DXCreateTextureFromFile(m_Device,s_szBoxPath,&m_TexCube);
}
//-------------------------------------------------------------------------
void CStencilOne::Cleanup()
{
	if (m_VB)
	{
		d3d::Release<IDirect3DVertexBuffer9*>(m_VB);
		m_VB = 0;
	}
	
	if (m_FloorTex)
	{
		d3d::Release<IDirect3DTexture9*>(m_FloorTex);
		m_FloorTex = 0;
	}
	
	if (m_WallTex)
	{
		d3d::Release<IDirect3DTexture9*>(m_WallTex);
		m_WallTex = 0;
	}

	if (m_MirrorTex)
	{
		d3d::Release<IDirect3DTexture9*>(m_MirrorTex);
		m_MirrorTex = 0;
	}

	if (m_Teapot)
	{
		d3d::Release<ID3DXMesh*>(m_Teapot);
		m_Teapot = 0;
	}

	if (m_TexCube)
	{
		d3d::Release<IDirect3DTexture9*>(m_TexCube);
		m_TexCube = 0;
	}

	if (m_VBCube)
	{
		d3d::Release<IDirect3DVertexBuffer9*>(m_VBCube);
		m_VBCube = 0;
	}

	if (m_IBCube)
	{
		d3d::Release<IDirect3DIndexBuffer9*>(m_IBCube);
		m_IBCube = 0;
	}
}
//-------------------------------------------------------------------------
bool CStencilOne::Display(float timeDelta)
{
	if (m_Device == 0)
	{
		return false;
	}
	//
	// Update the scene:
	//

	static float radius = 20.0f;

	if( ::GetAsyncKeyState(VK_LEFT) & 0x8000f )
		m_TeapotPosition.x -= 3.0f * timeDelta;

	if( ::GetAsyncKeyState(VK_RIGHT) & 0x8000f )
		m_TeapotPosition.x += 3.0f * timeDelta;

	if( ::GetAsyncKeyState(VK_UP) & 0x8000f )
		radius -= 2.0f * timeDelta;

	if( ::GetAsyncKeyState(VK_DOWN) & 0x8000f )
		radius += 2.0f * timeDelta;


	static float angle = (3.0f * D3DX_PI) / 2.0f;

	if( ::GetAsyncKeyState('A') & 0x8000f )
		angle -= 0.5f * timeDelta;

	if( ::GetAsyncKeyState('S') & 0x8000f )
		angle += 0.5f * timeDelta;

	D3DXVECTOR3 position( cosf(angle) * radius, 3.0f, sinf(angle) * radius );
	D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);
	D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
	D3DXMATRIX V;
	D3DXMatrixLookAtLH(&V, &position, &target, &up);
	m_Device->SetTransform(D3DTS_VIEW, &V);

	//
	// Draw the scene:
	//
	m_Device->Clear(0, 0, 
		D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL,
		0xff000000, 1.0f, 0L);

	m_Device->BeginScene();

	__RenderScene();

	__RenderShadow();

	__RenderMirror();	


	m_Device->EndScene();

	return true;
}
//-------------------------------------------------------------------------
void CStencilOne::__RenderScene()
{
	// draw teapot
// 	m_Device->SetMaterial(&m_TeapotMtrl);
// 	m_Device->SetTexture(0, 0);
	// draw box
	m_Device->SetMaterial(&m_TeapotMtrl);
	m_Device->SetTexture(0, m_TexCube);
	m_Device->SetStreamSource(0, m_VBCube, 0, sizeof(VertexStencil));
	m_Device->SetIndices(m_IBCube);
	m_Device->SetFVF(VertexStencil::FVF);

	// ÏÈÉèÖÃÊÀ½ç×ø±ê ÔÙäÖÈ¾,·ñÔòÏä×Ó»á±äÎ»ÖÃ
	D3DXMATRIX W;
	D3DXMatrixTranslation(&W,
		m_TeapotPosition.x, 
		m_TeapotPosition.y,
		m_TeapotPosition.z);

	m_Device->SetTransform(D3DTS_WORLD, &W);

	m_Device->DrawIndexedPrimitive(
		D3DPT_TRIANGLELIST, 
		0,                  
		0,                  
		24,
		0,
		12);  

	
	//m_Teapot->DrawSubset(0);

	D3DXMATRIX I;
	D3DXMatrixIdentity(&I);
	m_Device->SetTransform(D3DTS_WORLD, &I);

	m_Device->SetStreamSource(0, m_VB, 0, sizeof(VertexStencil));
	m_Device->SetFVF(VertexStencil::FVF);

	// draw the floor
	m_Device->SetMaterial(&m_FloorMtrl);
	m_Device->SetTexture(0, m_FloorTex);
	m_Device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);

	// draw the walls
	m_Device->SetMaterial(&m_WallMtrl);
	m_Device->SetTexture(0, m_WallTex);
	m_Device->DrawPrimitive(D3DPT_TRIANGLELIST, 6, 4);

	// draw the mirror
	m_Device->SetMaterial(&m_MirrorMtrl);
	m_Device->SetTexture(0, m_MirrorTex);
	m_Device->DrawPrimitive(D3DPT_TRIANGLELIST, 18, 2);
}
//-------------------------------------------------------------------------
// äÖÈ¾¾µ×ÓÉÏµÄÎï¼þ
void CStencilOne::__RenderMirror()
{
	//
	// Draw Mirror quad to stencil buffer ONLY.  In this way
	// only the stencil bits that correspond to the mirror will
	// be on.  Therefore, the reflected teapot can only be rendered
	// where the stencil bits are turned on, and thus on the mirror 
	// only.
	//

	// Õâ¶ÎµÄÒâË¼ÊÇ äÖÈ¾¾µ×ÓÎÆÀí  ²¢ÇÒÔÚ¾µ×ÓÉÏµÄÃ¿¸öÏñËØ×öÁË±ê¼Ç ±ê¼ÇÎª1
	{
		// ÉèÖÃÊ¹ÓÃ Ä£°æ»º³å ×´Ì¬Îª true
		m_Device->SetRenderState(D3DRS_STENCILENABLE,    true);
		// ÉèÖÃ Ä£°æ»º³å¹æÔò D3DCMP_ALWAYS ±íÊ¾È«²¿»º³å
		m_Device->SetRenderState(D3DRS_STENCILFUNC,      D3DCMP_ALWAYS);
		// ¿ØÖÆÄ£°æ²âÊÔ ÖÆ¶¨²Î¿¼Öµ Ä£°æÑÚÂë ÒÔ±ãÓÚÔËËã
		// ÉèÖÃ Ä£°æ²Î¿¼Öµ Ä¬ÈÏÎª0 ÉèÖÃÎª1 ºÃÏñÉèÖÃ 2 3 Ò²Ã»Ê²Ã´ÎÊÌâ
		m_Device->SetRenderState(D3DRS_STENCILREF,       0x1);
		// ÉèÖÃÄ£°æÑÚÂë ÓÃÀ´ÑÚÊÎ(Òþ²Ø)ÔÚrefºÍvalueÖÐµÄÖµ
		m_Device->SetRenderState(D3DRS_STENCILMASK,      0xffffffff);
		// ÉèÖÃÄ£°æÐ´ÑÚÂë ÑÚÊÎÎÒÃÇÐ´½øÄ£°æ»º´æµÄÈÎºÎÖµµÄÎ»
		m_Device->SetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);
		// ÌÈÈô ÏñËØÉî¶È²âÊÔ Ê§°Ü Ôò±£³ÖÔ­Ñù ÕâÀïÔ­ÑùÎªÐ´Èë(ËùÒÔ¾µ×Ó¿Ï¶¨È«²¿äÖÈ¾³öÀ´)
		m_Device->SetRenderState(D3DRS_STENCILZFAIL,     D3DSTENCILOP_KEEP);
		// ÌÈÈô ÏñËØÄ£°æ²âÊÔ Ê§°Ü Ôò±£³ÖÔ­Ñù ÕâÀïÔ­ÑùÎªÐ´Èë(ËùÒÔ¾µ×Ó¿Ï¶¨È«²¿äÖÈ¾³öÀ´)
		m_Device->SetRenderState(D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP);
		// ÌÈÈô ÏñËØÉî¶È²âÊÔ ºÍ ÏñËØÄ£°æ²âÊÔ ¶¼³É¹¦,ÔòÖ¸¶¨ÓÃ Ä£°æ²Î¿¼Öµ À´Ìæ»»Ä£°æ»º´æÈë¿Ú 
		m_Device->SetRenderState(D3DRS_STENCILPASS,      D3DSTENCILOP_REPLACE);

		// disable writes to the depth and back buffers
		// ×èÖ¹»òÕß ÔÊÐí Ð´ Éî¶È»º´æ
		m_Device->SetRenderState(D3DRS_ZWRITEENABLE, false);
		// ´ò¿ª alpha »ìºÏ Í¸Ã÷¶È»ìºÏ
		m_Device->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
		// ÉèÖÃ»ìºÏµÈÊ½µÄ²ÎÊý ÕâÀïÊÇ FinalPixel = sourcePixel x D3DBLEND_ZERO +	DestPixel x D3DBLEND_ONE
		m_Device->SetRenderState(D3DRS_SRCBLEND,  D3DBLEND_ZERO);
		m_Device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

		// draw the mirror to the stencil buffer
		// äÖÈ¾¾µ×Ó Õâ¸ö²»±Ø¶àËµ 
		m_Device->SetStreamSource(0, m_VB, 0, sizeof(VertexStencil));
		m_Device->SetFVF(VertexStencil::FVF);
		m_Device->SetMaterial(&m_MirrorMtrl);
		m_Device->SetTexture(0, m_MirrorTex);
		D3DXMATRIX I;
		D3DXMatrixIdentity(&I);
		m_Device->SetTransform(D3DTS_WORLD, &I);
		m_Device->DrawPrimitive(D3DPT_TRIANGLELIST, 18, 2);

		// re-enable depth writes
		// ×èÖ¹»òÕß ÔÊÐí Ð´ Éî¶È»º´æ
		m_Device->SetRenderState( D3DRS_ZWRITEENABLE, true );
	}
	
	// ÕâÁ½¾äµÄÏÞ¶¨ÁË ²âÊÔ±ØÐëÊÇ ÉÏÃæ¾µ×ÓµÄÏñËØ²Å»á³É¹¦.¼òµ¥À´Ëµ ¾ÍÊÇÒ»¸öÏñËØ±ê¼Ç
	// ÌÈÈôÏñËØµã ²»ÔÚ ¾µ×ÓÉÏ(Î´±»±ê¼ÇÎª1) Ôò²»»á¼ÓÈëÄ£°æ»º´æ
	{
		// only draw reflected teapot to the pixels where the mirror
		// was drawn to.
		// ÉèÖÃ Ä£°æ»º´æ¹æÔò D3DCMP_EQUAL ±íÊ¾ÏàµÈµÄÄ£°æ²Î¿¼Öµ,±£Ö¤ÁËÖ»äÖÈ¾ÔÚ¾µ×ÓÉÏ
		// Èç¹ûÕâÀï¸Ä³ÉD3DCMP_ALWAYS Ïä×ÓµÄ·´Éä»áÒ»Ö±´æÔÚ ²»¹ÜÊÇ·ñÍÑÀë¾µ×Ó
		m_Device->SetRenderState(D3DRS_STENCILFUNC,  D3DCMP_EQUAL);
		// Èç¹ûÏñËØÉî¶È²âÊÔ ºÍ ÏñËØÄ£°æ²âÊÔ ¶¼³É¹¦ Ôò±£´æÄ£°æ»º´æµÄÖµ
		m_Device->SetRenderState(D3DRS_STENCILPASS,  D3DSTENCILOP_KEEP);
	}
	

	// ¼ÆËãÏä×Ó  ÔÚ³¡¾°ÖÐ ·´ÉäÎ»ÖÃµÄ¾ØÕó 
	// position reflection
	D3DXMATRIX W, T, R;
	D3DXPLANE plane(0.0f, 0.0f, 1.0f, 0.0f); // xy plane
	D3DXMatrixReflect(&R, &plane);

	D3DXMatrixTranslation(&T,
		m_TeapotPosition.x, 
		m_TeapotPosition.y,
		m_TeapotPosition.z); 

	W = T * R;

	// clear depth buffer and blend the reflected teapot with the mirror
	// ÇåÀí Éî¶È»º´æ
	// ÒòÎª±»·´ÉäµÄ Ïä×Ó µÄÉî¶È ±È ¾µ×ÓµÄÉî¶È´ó,Òò´Ë¾µ×ÓµÄÍ¼Ôª ½«±»·´ÉäÏä×ÓµÄÍ¼ÔªÅªÄ£ºý(ÕÚ×¡?)
	// ÎªÁË±ÜÃâÕâÖÖÇé¿ö ÎÒÃÇÇå³þ Éî¶È »º´æ
	m_Device->Clear(0, 0, D3DCLEAR_ZBUFFER, 0, 1.0f, 0);
	// ÉèÖÃ»ìºÏµÈÊ½µÄ²ÎÊý ÕâÀïÊÇ FinalPixel = sourcePixel x D3DBLEND_DESTCOLOR +	DestPixel x D3DBLEND_ZERO
	// ÉÏÃæ¹«Ê½´ú±íµÄÊÇ Ïä×ÓÔÚäÖÈ¾ÔÚ ¾µ×ÓÏñËØËùÔÚµÄÎ»ÖÃµÄÊ±ºò,
	// ¸ÃÎ»ÖÃµÄÏñËØ Òª»ìºÏ ¾µ×ÓÏñËØ ºÍ Ïä×ÓÏñËØ ÕâÑù¿´ÆðÀ´¸üÕæÊµ.
	m_Device->SetRenderState(D3DRS_SRCBLEND,  D3DBLEND_DESTCOLOR);
	m_Device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);

	// ÏÂÃæÊÇäÖÈ¾Ïä×Ó ×ÔÈ»²»±Ø½âÊÍ
	// Finally, draw the reflected teapot
	m_Device->SetTransform(D3DTS_WORLD, &W);

	m_Device->SetMaterial(&m_TeapotMtrl);
	m_Device->SetTexture(0, m_TexCube);
	m_Device->SetStreamSource(0, m_VBCube, 0, sizeof(VertexStencil));
	m_Device->SetIndices(m_IBCube);
	m_Device->SetFVF(VertexStencil::FVF);

	// ÉèÖÃ ±³²¿¼ðÑ¡ ¼ðÑ¡Ë³Ê±Õë..µÄÈý½ÇÐÎ Èç¹û²»ÉèÖÃÕâ¸ö..Ôò¾µ×ÓÀïäÖÈ¾³öÀ´µÄÊÇÏä×ÓÄÚ²¿...Orz
	m_Device->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);

	m_Device->DrawIndexedPrimitive(
		D3DPT_TRIANGLELIST, 
		0,                  
		0,                  
		24,
		0,
		12);  

// 	m_Device->SetMaterial(&m_TeapotMtrl);
// 	m_Device->SetTexture(0, 0);

	//m_Device->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);
	//m_Teapot->DrawSubset(0);

	// Restore render states.
	// ¹Ø±Õ Í¸Ã÷¶È alpha »ìºÏ
	m_Device->SetRenderState(D3DRS_ALPHABLENDENABLE, false);
	// ÉèÖÃÊ¹ÓÃ Ä£°æ»º³å ×´Ì¬Îª false
	m_Device->SetRenderState( D3DRS_STENCILENABLE, false);
	// ÉèÖÃ ±³²¿¼ðÑ¡ ¼ðÑ¡ÄæÊ±Õë..µÄÈý½ÇÐÎ Ä¬ÈÏÖµ
	m_Device->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
}
//-------------------------------------------------------------------------
void CStencilOne::__RenderShadow()
{
	// ·ÀÖ¹¶àÖØäÖÈ¾µÄ»ìºÏ Ä£°æ»º´æËã·¨
	// ´ó¸ÅÒâË¼¾ÍÊÇ ÏÈÈ«²¿ÉèÖÃÎª0 È»ºóäÖÈ¾Ò»¸ö+1.
	// µ±Ä³ÏñËØ²»Îª0 µÄÊ±ºò ²»Ëã·¨
	// ÕâÑù·ÀÖ¹Ä³¸öÏñËØÖØ¸´äÖÈ¾
	// ×èÖ¹ÁËÖØÓ° ÖØµþ Ö®ÀàµÄÇé¿ö·¢Éú 
	{
		// ÉèÖÃÊ¹ÓÃ Ä£°æ»º³å ×´Ì¬Îª true
		m_Device->SetRenderState(D3DRS_STENCILENABLE,    true);
		// ÉèÖÃ Ä£°æ»º³å¹æÔò D3DCMP_EQUAL ±íÊ¾ÐèÒªÓë Ä£°æ²Î¿¼Öµ ÏàµÈ
		m_Device->SetRenderState(D3DRS_STENCILFUNC,      D3DCMP_EQUAL);
		// ¿ØÖÆÄ£°æ²âÊÔ ÖÆ¶¨²Î¿¼Öµ Ä£°æÑÚÂë ÒÔ±ãÓÚÔËËã
		// ÉèÖÃ Ä£°æ²Î¿¼Öµ Ä¬ÈÏÎª0 ÉèÖÃÎª0 
		m_Device->SetRenderState(D3DRS_STENCILREF,       0x0);
		// ÉèÖÃÄ£°æÑÚÂë ÓÃÀ´ÑÚÊÎ(Òþ²Ø)ÔÚrefºÍvalueÖÐµÄÖµ
		m_Device->SetRenderState(D3DRS_STENCILMASK,      0xffffffff);
		// ÉèÖÃÄ£°æÐ´ÑÚÂë ÑÚÊÎÎÒÃÇÐ´½øÄ£°æ»º´æµÄÈÎºÎÖµµÄÎ»
		m_Device->SetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);
		// ÌÈÈô ÏñËØÉî¶È²âÊÔ Ê§°Ü Ôò±£³ÖÔ­Ñù ÕâÀïÔ­ÑùÎªÐ´Èë(ËùÒÔ¾µ×Ó¿Ï¶¨È«²¿äÖÈ¾³öÀ´)
		m_Device->SetRenderState(D3DRS_STENCILZFAIL,     D3DSTENCILOP_KEEP);
		// ÌÈÈô ÏñËØÄ£°æ²âÊÔ Ê§°Ü Ôò±£³ÖÔ­Ñù ÕâÀïÔ­ÑùÎªÐ´Èë(ËùÒÔ¾µ×Ó¿Ï¶¨È«²¿äÖÈ¾³öÀ´)
		m_Device->SetRenderState(D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP);
		// ÌÈÈô ÏñËØÉî¶È²âÊÔ ºÍ ÏñËØÄ£°æ²âÊÔ ¶¼³É¹¦,ÔòÖ¸¶¨ÓÃ Ä£°æ²Î¿¼Öµ +1,²Î¿¼ÖµÎª0 ËùÒÔÕâÀïÎª1
		m_Device->SetRenderState(D3DRS_STENCILPASS,      D3DSTENCILOP_INCR);
	}
	
	// Í¨¹ý·½Ïò¹â ¼ÆËãÔÚ Ä³Æ½ÃæµÄÒõÓ°
	{
		// ¹âÔ´ ·½Ïò¹â
		D3DXVECTOR4 lightDirection(0.707f,-0.707f,0.707f,0.0f);
		// Æ½Ãæ
		D3DXPLANE groundPlane(0.0f,-1.0f,0.0f,0.0f);

		D3DXMATRIX S;
		// ¼ÆËãÓ°×Ó
		D3DXMatrixShadow(&S,&lightDirection,&groundPlane);

		D3DXMATRIX T;
		D3DXMatrixTranslation(&T,m_TeapotPosition.x,m_TeapotPosition.y,m_TeapotPosition.z);

		// ¼ÆËãm_TeapotPositionÎ»ÖÃµÄÒõÓ°
		D3DXMATRIX W = T * S;

		m_Device->SetTransform(D3DTS_WORLD,&W);
	}
	
	// ´ò¿ª alpha »ìºÏ Í¸Ã÷¶È»ìºÏ
	m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, true );
	// ÉèÖÃ»ìºÏµÈÊ½µÄ²ÎÊý »ìºÏÍ¸Ã÷¶È¹æÔò
	m_Device->SetRenderState(D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA);
	// ¼´1¼õÈ¥µ±Ç°»æÖÆÏñËØµÄalphaÖµ
	m_Device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	D3DMATERIAL9 mtrl = d3d::InitMtrl(d3d::BLACK,d3d::BLACK,d3d::BLACK,d3d::BLACK,0.0f);
	mtrl.Diffuse.a = 0.5f;

	m_Device->SetRenderState(D3DRS_ZENABLE,false);
	m_Device->SetMaterial(&mtrl);

	m_Device->SetTexture(0, m_TexCube);
	m_Device->SetStreamSource(0, m_VBCube, 0, sizeof(VertexStencil));
	m_Device->SetIndices(m_IBCube);
	m_Device->SetFVF(VertexStencil::FVF);


	m_Device->DrawIndexedPrimitive(
		D3DPT_TRIANGLELIST, 
		0,                  
		0,                  
		24,
		0,
		12);  

	m_Device->SetRenderState(D3DRS_ZENABLE,true);
	m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, false );
	m_Device->SetRenderState(D3DRS_STENCILENABLE,    false);
}